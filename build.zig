const std = @import("std");
const EmbedFile = @This();

wf: *std.Build.Step.WriteFile,
contents: std.ArrayListUnmanaged(u8),
module: *std.Build.Module,
named_wfs: std.ArrayListUnmanaged(*std.Build.Step.WriteFile),

/// creates a new EmbedFile step
pub fn create(owner: *std.Build) *EmbedFile {
    const embed_file = owner.allocator.create(EmbedFile) catch @panic("OOM");
    embed_file.* = .{
        .wf = std.Build.Step.WriteFile.create(owner),
        .module = owner.createModule(.{}),
        .contents = .{},
        .named_wfs = .{},
    };
    const canonicalize = owner.addSystemCommand(&.{ owner.graph.zig_exe, "fmt", "--stdin" });
    canonicalize.setStdIn(.{ .lazy_path = embed_file.wf.getDirectory().path(owner, "module.zig") });
    const module_file = canonicalize.captureStdOut();
    embed_file.module.root_source_file = module_file;
    embed_file.contents.appendSlice(owner.allocator,
        \\//! This file is automatically generated by EmbedFile.zig!
        \\//! EmbedFile.zig is NOT an official part of the Zig build system;
        \\//! please report any issues at https://github.com/robbielyman/EmbedFile.zig
        \\
        \\
    ) catch @panic("OOM");
    embed_file.updateContents();
    return embed_file;
}

pub fn addEmbedFiles(b: *std.Build) *EmbedFile {
    return EmbedFile.create(b);
}

pub fn addEmbedFile(b: *std.Build, name: []const u8, bytes: []const u8, alignment: ?u29) *EmbedFile {
    const ret = EmbedFile.create(b);
    ret.add(name, bytes, alignment);
    return ret;
}

fn updateContents(embed_file: *EmbedFile) void {
    if (embed_file.wf.files.items.len == 0) {
        _ = embed_file.wf.add("module.zig", embed_file.contents.items);
        return;
    }
    embed_file.wf.files.items[0].contents = .{ .bytes = embed_file.contents.items };
}

const Kind = enum { file, directory };

fn getRun(b: *std.Build) *std.Build.Step.Run {
    const this_dep = b.dependencyFromBuildZig(@This(), .{
        .target = b.graph.host,
        .optimize = .Debug,
    });
    const exe = this_dep.artifact("embed-file");
    return b.addRunArtifact(exe);
}

fn addImport(
    embed_file: *EmbedFile,
    run: *std.Build.Step.Run,
    name: []const u8,
    kind: Kind,
) void {
    const b = run.step.owner;
    const input = run.captureStdOut();
    run.addArg("--output");
    const output_dir = run.addOutputDirectoryArg(name);
    const fmt = b.addSystemCommand(&.{ b.graph.zig_exe, "fmt", "--stdin" });
    fmt.setStdIn(.{ .lazy_path = input });
    const output = fmt.captureStdOut();
    const copy_file = b.addWriteFiles();
    const module_file = copy_file.addCopyFile(output, "module.zig");
    _ = copy_file.addCopyDirectory(output_dir, "", .{});
    for (embed_file.named_wfs.items) |wf| {
        _ = wf.addCopyDirectory(copy_file.getDirectory(), name, .{});
    }
    const import_module = b.createModule(.{
        .root_source_file = module_file,
    });
    embed_file.module.addImport(name, import_module);
    switch (kind) {
        .file => embed_file.contents.writer(b.allocator).print(
            \\pub const @"{s}" = @import("{s}").@"{s}";
            \\
        , .{ name, name, name }) catch @panic("OOM"),
        .directory => embed_file.contents.writer(b.allocator).print(
            \\pub const @"{s}" = @import("{s}");
            \\
        , .{ name, name }) catch @panic("OOM"),
    }
    embed_file.updateContents();
}

/// adds a declaration by name, contents and alignment directly
pub fn add(embed_file: *EmbedFile, name: []const u8, bytes: []const u8, alignment: ?u29) void {
    const b = embed_file.module.owner;
    const write_file = b.addWriteFile(name, bytes);
    const run = getRun(b);
    run.addFileArg(write_file.files.items[0].getPath());
    if (alignment) |a| run.addArg(b.fmt("{d}", .{a}));
    embed_file.addImport(run, name, .file);
}

/// name is the eventual declaration name to be used,
/// while source is the path as it exists on the file system
pub fn addFile(
    embed_file: *EmbedFile,
    source: std.Build.LazyPath,
    name: []const u8,
    alignment: ?u29,
) void {
    const b = embed_file.module.owner;
    const run = getRun(b);
    run.addFileArg(source);
    if (alignment) |a| run.addArg(b.fmt("{d}", .{a}));
    run.addArg("--rename");
    run.addArg(name);
    embed_file.addImport(run, name, .file);
}

/// name is the eventual declaration name to be used as a namespace,
/// while source is the path as it exists on the file system
/// files matching the Directory.Options specification
/// are made available as declarations namespaced under "name";
/// the filename (minus any extension) is used as the declaration name
/// alignment, if non-null, is used as the alignment for all sub-declarations
pub fn addDirectory(
    embed_file: *EmbedFile,
    source: std.Build.LazyPath,
    options: std.Build.Step.WriteFile.Directory.Options,
    name: []const u8,
    alignment: ?u29,
) void {
    const b = embed_file.module.owner;
    const run = getRun(b);
    run.addDirectoryArg(source);
    if (alignment) |a| run.addArg(b.fmt("{d}", .{a}));
    if (options.exclude_extensions.len > 0) {
        const arg = std.mem.join(b.allocator, ",", options.exclude_extensions) catch @panic("OOM");
        run.addArgs(&.{ "--exclude", arg });
    }
    if (options.include_extensions) |include| {
        const arg = std.mem.join(b.allocator, ",", include) catch @panic("OOM");
        run.addArgs(&.{ "--include", arg });
    }
    embed_file.addImport(run, name, .directory);
}

/// returns a `LazyPath` representing the Zig source file generated from this `EmbedFile`
pub fn getSource(embed_file: *EmbedFile) std.Build.LazyPath {
    return embed_file.module.root_source_file.?;
}

/// adds a named WriteFile step that collects all of this EmbedFile's dependencies to write out
pub fn writeSources(embed_file: *EmbedFile, name: []const u8) *std.Build.Step.WriteFile {
    const owner = embed_file.module.owner;
    const gpa = owner.allocator;
    const new_wf = owner.addNamedWriteFiles(name);
    // collect all currently existing dependencies
    // addImport will add the rest
    var it = embed_file.module.iterateDependencies(null, false);
    while (it.next()) |item| if (std.mem.eql(u8, item.name, "root")) {
        _ = new_wf.addCopyFile(item.module.root_source_file.?, "module.zig");
    } else {
        _ = new_wf.addCopyDirectory(item.module.root_source_file.?.dirname(), item.name, .{});
    };

    embed_file.named_wfs.append(gpa, new_wf) catch @panic("OOM");
    return new_wf;
}

pub fn build(b: *std.Build) void {
    const target = b.standardTargetOptions(.{});
    const optimize = b.standardOptimizeOption(.{});

    const exe = b.addExecutable(.{
        .name = "embed-file",
        .target = target,
        .optimize = optimize,
        .root_source_file = b.path("src/main.zig"),
    });
    b.installArtifact(exe);
}
