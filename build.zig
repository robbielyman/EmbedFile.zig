const std = @import("std");
const EmbedFile = @This();

wf: *std.Build.Step.WriteFile,
contents: std.ArrayListUnmanaged(u8),
module: *std.Build.Module,
named_wfs: std.ArrayListUnmanaged(*std.Build.Step.WriteFile),

/// creates a new EmbedFile step
pub fn create(owner: *std.Build) *EmbedFile {
    const embed_file = owner.allocator.create(EmbedFile) catch @panic("OOM");
    embed_file.* = .{
        .wf = std.Build.Step.WriteFile.create(owner),
        .module = owner.createModule(.{}),
        .contents = .{},
        .named_wfs = .{},
    };
    const canonicalize = owner.addSystemCommand(&.{ owner.graph.zig_exe, "fmt", "--stdin" });
    canonicalize.setStdIn(.{ .lazy_path = embed_file.wf.getDirectory().path(owner, "module.zig") });
    const module_file = canonicalize.captureStdOut();
    embed_file.module.root_source_file = module_file;
    embed_file.contents.appendSlice(owner.allocator,
        \\//! This file is automatically generated by EmbedFile.zig!
        \\//! EmbedFile.zig is NOT an official part of the Zig build system;
        \\//! please report any issues at https://github.com/robbielyman/EmbedFile.zig
        \\
        \\
    ) catch @panic("OOM");
    embed_file.updateContents();
    return embed_file;
}

pub fn addEmbedFiles(b: *std.Build) *EmbedFile {
    return EmbedFile.create(b);
}

pub fn addEmbedFile(b: *std.Build, name: []const u8, bytes: []const u8, alignment: ?u29) *EmbedFile {
    const ret = EmbedFile.create(b);
    ret.add(name, bytes, alignment);
    return ret;
}

fn updateContents(embed_file: *EmbedFile) void {
    if (embed_file.wf.files.items.len == 0) {
        _ = embed_file.wf.add("module.zig", embed_file.contents.items);
        return;
    }
    embed_file.wf.files.items[0].contents = .{ .bytes = embed_file.contents.items };
}

const Kind = enum { file, directory };

fn addImport(
    embed_file: *EmbedFile,
    b: *std.Build,
    write_file: *std.Build.Step.WriteFile,
    name: []const u8,
    kind: Kind,
    alignment: ?u29,
) void {
    const this_dep = b.dependencyFromBuildZig(@This(), .{
        .target = b.graph.host,
        .optimize = .Debug,
    });
    const exe = this_dep.artifact("embed-file");
    const run = b.addRunArtifact(exe);
    switch (kind) {
        .file => run.addFileArg(write_file.getDirectory().path(b, name)),
        .directory => run.addDirectoryArg(write_file.getDirectory().path(b, name)),
    }
    if (alignment) |a| run.addArg(b.fmt("{d}", .{a}));
    run.step.dependOn(&write_file.step);
    const input = run.captureStdOut();
    const fmt = b.addSystemCommand(&.{ b.graph.zig_exe, "fmt", "--stdin" });
    fmt.setStdIn(.{ .lazy_path = input });
    const output = fmt.captureStdOut();
    const copy_file = b.addWriteFiles();
    const module_file = copy_file.addCopyFile(output, "module.zig");
    _ = copy_file.addCopyDirectory(write_file.getDirectory(), "", .{});
    for (embed_file.named_wfs.items) |wf| {
        _ = wf.addCopyDirectory(copy_file.getDirectory(), name, .{});
    }
    const import_module = b.createModule(.{
        .root_source_file = module_file,
    });
    embed_file.module.addImport(name, import_module);
    switch (kind) {
        .file => embed_file.contents.writer(b.allocator).print(
            \\pub const @"{s}" = @import("{s}").@"{s}";
            \\
        , .{ name, name, name }) catch @panic("OOM"),
        .directory => embed_file.contents.writer(b.allocator).print(
            \\pub const @"{s}" = @import("{s}");
            \\
        , .{ name, name }) catch @panic("OOM"),
    }
    embed_file.updateContents();
}

/// adds a declaration by name, contents and alignment directly
pub fn add(embed_file: *EmbedFile, name: []const u8, bytes: []const u8, alignment: ?u29) void {
    const b = embed_file.module.owner;
    const write_file = b.addWriteFile(name, bytes);
    embed_file.addImport(b, write_file, name, .file, alignment);
}

/// name is the eventual declaration name to be used,
/// while source is the path as it exists on the file system
pub fn addFile(
    embed_file: *EmbedFile,
    source: std.Build.LazyPath,
    name: []const u8,
    alignment: ?u29,
) void {
    const b = embed_file.module.owner;
    const write_file = b.addWriteFiles();
    _ = write_file.addCopyFile(source, name);
    embed_file.addImport(b, write_file, name, .file, alignment);
}

/// name is the eventual declaration name to be used as a namespace,
/// while source is the path as it exists on the file system
/// files matching the Directory.Options specification
/// are made available as declarations namespaced under "name";
/// the filename (minus any extension) is used as the declaration name
/// alignment, if non-null, is used as the alignment for all sub-declarations
pub fn addDirectory(
    embed_file: *EmbedFile,
    source: std.Build.LazyPath,
    options: std.Build.Step.WriteFile.Directory.Options,
    name: []const u8,
    alignment: ?u29,
) void {
    const b = embed_file.module.owner;
    const write_file = b.addWriteFiles();
    _ = write_file.addCopyDirectory(source, name, options);
    embed_file.addImport(b, write_file, name, .directory, alignment);
}

/// returns a `LazyPath` representing the Zig source file generated from this `EmbedFile`
pub fn getSource(embed_file: *EmbedFile) std.Build.LazyPath {
    return embed_file.module.root_source_file.?;
}

/// adds a named WriteFile step that collects all of this EmbedFile's dependencies to write out
pub fn writeSources(embed_file: *EmbedFile, name: []const u8) *std.Build.Step.WriteFile {
    const owner = embed_file.module.owner;
    const gpa = owner.allocator;
    const new_wf = owner.addNamedWriteFiles(name);
    // collect all currently existing dependencies
    // addImport will add the rest
    var it = embed_file.module.iterateDependencies(null, false);
    while (it.next()) |item| if (std.mem.eql(u8, item.name, "root")) {
        _ = new_wf.addCopyFile(item.module.root_source_file.?, "module.zig");
    } else {
        _ = new_wf.addCopyDirectory(item.module.root_source_file.?.dirname(), item.name, .{});
    };

    embed_file.named_wfs.append(gpa, new_wf) catch @panic("OOM");
    return new_wf;
}

pub fn build(b: *std.Build) void {
    const target = b.standardTargetOptions(.{});
    const optimize = b.standardOptimizeOption(.{});

    const exe = b.addExecutable(.{
        .name = "embed-file",
        .target = target,
        .optimize = optimize,
        .root_source_file = b.path("src/main.zig"),
    });
    b.installArtifact(exe);
}
